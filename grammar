start =                 simple_input*

simple_input =          __ (delimiters / compound_stmt / simple_stmt) __
inline_simple_input =   compound_stmt / simple_stmt

delimiters =            (';' / '\n')+
_ =                     (' ' / '\t')*
__ =                    ( ' ' / '\t' / '\n')*


simple_stmt =           flow_stmt / argument
flow_stmt =             break_stmt / next_stmt
break_stmt =            'break'
next_stmt =             'next'

compound_stmt =          repeat_stmt / for_stmt / while_stmt / funcdef / condition_stmt
repeat_stmt =           'repeat' __ suite
for_stmt =              'for' __ '(' __ Variable __ 'in' __ argument __ ')' suite
while_stmt =            'while' __ '(' __ argument __ ')' suite
condition_stmt =        if_case __ elif_case* __ else_case?
if_case =               'if' __ '(' __ argument __ ')' suite
elif_case =             'else' __ 'if' __ '(' __ argument __ ')' suite
else_case =             'else' suite


expr =                  or_expr
or_expr =               and_expr _ ( OrOp __ and_expr )*
and_expr =              not_expr _ ( AndOp __ not_expr )*
not_expr =              ( NotOp __ not_expr) / compare_expr
compare_expr =          arith_expr _ ( CompOp __ arith_expr)?
arith_expr =            term __ ( PlusMinOp __ term)*
term =                  special_term __ ( MultDivOp __ special_term )*
special_term =          sequence_term __ ( UserOp __ sequence_term )*
sequence_term =         factor ( __ SeqOp __ factor )?
factor =                ( PlusMinOp __ factor ) / power
power =                 assign_item ( __ FactOp __ factor )*


assign_expr =           simple_assign / left_assign / right_assign
simple_assign =         assign_item _ '=' __ expr_item
left_assign =           assign_item _ ('<<-' / '<-' ) __ expr_item
right_assign =          expr_item _ ('->' /'->>') __ assign_item
assign_item =           atom (trailer)*
atom =                  ( '(' __ argument __')' ) / Dots / Logical / Integer / Numeric /  Character / Null / Na / Nan / Inf / Variable


trailer =               call / indexing / subname
call =                  '(' __ (argument ( __ ',' __ argument )*)? __ ')'
indexing =              '[' __ (argument ( __ ',' __ argument )*)? __ ']'
list_indexing =         '[[' __ argument? __ ']]'
subname =               '$' Variable
argument =              funcdef / assign_expr / expr
index =                 argument / empty

empty =                 ''

expr_item =             funcdef / expr

funcdef =               'function' __ '(' __ ( func_argument (_',' __ func_argument)* )? __ (',' __ Dots __ )? ')' suite
func_argument =         Variable ( _ '=' __ expr_item)?

suite =                 __ (('{' simple_input* '}') / inline_simple_input )



Logical =           'TRUE' / 'FALSE'
Numeric =           ~r'([0-9]*(\.[0-9]+))|([0-9]+(\.[0-9]+)?)'i
Integer =           ~r'[0-9]L'i
Complex =           Numeric 'i'
Variable =          ~r'(([.]*[a-zA-Z]+)|([.]{2,}[\d]*)|([.]+[_]+))[a-zA-Z_\d.]*'
Character =         ( ~r'("[^"\\]*(?:\\.[^"\\]*)*")'i ) / ( ~r"('[^'\\]*(?:\\.[^'\\]*)*')"i )
Dlr =               '$'
Dots =              '...'
Null =              'NULL'
Na =                'NA'
Nan =               'NaN'
Inf =               'Inf'
OrOp =              '||' / '|'
AndOp =             '&&' / '&'
NotOp =             '!'
PlusMinOp =         '+' / '-'
MultDivOp =         '*' / '/'
UserOp =            ~r'%[^%]%'i
SeqOp =             ':'
FactOp =            '^'
CompOp =            '>' / '<' / '>=' / '<=' / '!=' / '=='